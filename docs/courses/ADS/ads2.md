# Red Black tree（红黑树）
红黑树的目的是为了构建平衡二叉搜索树，其结点除包含键值和左右子树指针外，还有颜色字段

红黑树的内部节点即树本身具有的结点；外部节点是指每个内部节点的空孩子，我们称之为`NIL`结点，它也是黑色的；

若算上外部节点`NIL`，则红黑树的叶结点均为`NIL`
## 定义
红黑树是满足下列5条性质的**BST**

1. 每个结点非红即黑 
2. root为黑
3. 每个叶结点（`NIL`）均为黑色
4. 若某结点为红色，则它的两个孩子均为黑色
5. 对与每一个结点，从它开始的所有simple path（一路向下直到`NIL`）都包含相同数量的黑节点

### 子定义
黑高(black-height, bh)：某结点的黑高为从该结点开始的simple path上包含的黑结点数量（不包括自身）；bh(tree)=bh(root)

## 性质
有n个内部节点的红黑树，高度最大是 $2\log_2 (n+1)$

!!! proof "Height of RB Trees"
    > 一个显然的前提：任何simple path上的黑结点数大于等于红结点数

    1. 首先有 $n\ge 2^{bh}-1$，即 $bh\le \log_2(n+1)$
    2. 又显然有 $2bh(Tree)\ge h(Tree)$
    3. 因此 $h(Tree)\le 2\log_2 (n+1)$

## 操作
### insert
> 我们在插入新结点时一律将其设为红色，后续进行调整

+ 新结点的父亲为黑色，则无需调整
+ 新结点的父亲为红色
则有以下3种情况
!!! note
    由于新插入的结点也有子节点`NIL`，而在调整过程中也会出现父辈中的红结点违例现象，因此所有红结点在示意图中均有两个孩子，且“被插入的红色结点”未必是最底层的结点

!!! example
    ![](pics/rbtree.png){ align=left width="400" }

    + case3: 叔叔为黑，自己是叔叔的远侄

    可直接解决，不用递归向上

    -----
    
    + case2: 叔叔为黑，自己为叔叔的近侄

    先旋转成远侄，再按case3操作

    可直接解决，不用递归向上
    
    -----

    + case1: 叔叔为红

    将爷爷的黑向下传递给两个孩子（下放），爷爷变红，将问题抛给爷爷解决

!!! example "RBtree insert"
    === "case3"
        ![](pics/rbins3.png)
    === "case2"
        ![](pics/rbins2.png){width="600"}
    === "case1"
        ![](pics/rbins1.png){width="400"}
### delete
    
# B+ tree（B+树）